<script src="/static/jquery-3.2.1/jquery.min.js"></script>
<script src="/static/threejs/build/three.js"></script>
<script src="/static/threejs/external/OrbitControls.js"></script>
<script src="/static/threejs/external/STLExporter.js"></script>
<script src="/static/threejs/examples/js/loaders/STLLoader.js"></script>

<script src="/static/editor/js/Uuid.js"></script>
<script src="/static/editor/js/UserSettings.js"></script>
<script src="/static/editor/js/LocalDataSource.js"></script>
<script src="/static/editor/js/SceneView.js"></script>
<script src="/static/editor/js/Character.js"></script>
<script src="/static/editor/js/BoneGroup.js"></script>
<script src="/static/editor/js/BoneGroupTemplate.js"></script>
<script src="/static/editor/js/AssetTemplate.js"></script>
<script src="/static/editor/js/Asset.js"></script>
<script src="/static/editor/js/Preset.js"></script>
<script src="/static/editor/js/Pose.js"></script>
<script src="/static/editor/js/Materials.js"></script>
<script src="/static/editor/js/PickingView.js"></script>
<script src="/static/editor/js/Event.js"></script>
<script src="/static/editor/js/ObservableDict.js"></script>
<script src="/static/editor/js/ObservableList.js"></script>
<script src="/static/editor/js/FileSaver.js"></script>
<script src="/static/editor/js/Global.js"></script>

<script src="/static/sweetalert2/js/sweetalert2.min.js"></script>
<link rel="stylesheet" href="/static/sweetalert2/css/sweetalert2.min.css">

<script>
  mode = 'mesh';

  boneGroupTemplates = {};
  assetTemplates = {};
  presets = {};

  boneGroups = new ObservableDict(this);

  materials = new Materials();
  view = new SceneView(); // This is the three.js panel
  view.animate();
  meshPickingView = new PickingView();
  selectedAsset = null;

  $(document).ready( function(){
    view.onWindowResize(); // Resize three.js panel to correct starting size
    meshPickingView.onWindowResize(); // Resize the mesh picking view too

    initializeBoneGroupTemplates();
    initializeAssetTemplates();
    initializePresets();
    initializeMaterials();

    loadPreset("b18a412a-00fc-4cf9-9df5-d80066bc05e7");
  });


  function initializeBoneGroupTemplates(){
    {% for bone_group in bone_groups %}
      var template = new BoneGroupTemplate("{{ bone_group.id }}",
                                         "{{ bone_group.name }}",
                                         "{{ bone_group.description }}",
                                         "{{ bone_group.author }}",
                                         "{{ bone_group.categories }}".split(","),
                                         "{{ bone_group.date_created }}",
                                         "{{ bone_group.thumbnail.url }}",
                                         "{{ bone_group.file.url }}")
      boneGroupTemplates["{{ bone_group.id }}"] = template;
    {% endfor %}
  }

  function initializeAssetTemplates(){
    {% for asset in assets %}
      var template = new AssetTemplate("{{ asset.id }}",
                                       "{{ asset.name }}",
                                       "{{ asset.description }}",
                                       "{{ asset.author }}",
                                       "{{ asset.category }}",
                                       "{{ asset.date_created }}",
                                       "{{ asset.thumbnail.url }}",
                                       "{{ asset.mesh.url }}",
                                       "{{ asset.mesh_hires.url }}",
                                       "{{ asset.mesh_lowres.url }}")
      assetTemplates["{{ asset.id }}"] = template;
    {% endfor %}
  }

  function initializePresets(){
    {% for preset in presets %}
      var preset = new Preset( "{{ preset.id }}",
                               "{{ preset.name }}",
                               "{{ preset.description }}",
                               "{{ preset.author }}",
                               "{{ preset.category }}",
                               "{{ preset.date_created }}",
                               "{{ preset.thumbnail.url }}",
                               "{{ preset.file.url }}")
      presets["{{ preset.id }}"] = preset;
    {% endfor %}
  }

  function initializeMaterials(){
    materials.metallic = Materials.createReflectiveMaterial(new THREE.Color(0.75, 0.75, 0.7), .3, view.cubeMap);
    materials.selected = Materials.createReflectiveMaterial(new THREE.Color(0.7, .8, .9), .2, view.cubeMap);
    materials.boneGroupSelected = Materials.createReflectiveMaterial(new THREE.Color(0.9, .8, .6), .2, view.cubeMap);
    materials.clay = Materials.createReflectiveMaterial(new THREE.Color(0.5, 0.4, 0.5), 0.02, view.cubeMap);
    materials.default = materials.metallic;
  }

  function addBoneGroup(boneGroup){
    boneGroups.put(boneGroup.uid, boneGroup);
  }

  function removeBoneGroup(uid){
    // Remove meshes attached to bone group
    var boneGroupToRemove = boneGroups.get(uid);
    for (var meshName in boneGroupToRemove.assets.dict){
      boneGroupToRemove.removeMesh(meshName);
    }

    for (var boneGroupUid in boneGroups.dict){
      var boneGroup = boneGroups.get(boneGroupUid);
      if (boneGroup.parentBoneGroupUid === uid){ //Remove child bone groups.
        this.removeBoneGroup(boneGroupUid);
      }
    }
    boneGroups.remove(uid);
  }

  function getCurrentPose(){
    return Pose.toPose(boneGroups);
  }

  function loadBoneScales(pose){
    for (var i = 0; i < pose.poseBones.length; i++){
      var poseBone = pose.poseBones[i];

      for (var boneGroupUid in boneGroups.dict){
        var boneGroup = boneGroups.get(boneGroupUid);

        for (var j = 0; j < boneGroup.skeleton.bones.length; j++){
          var bone = boneGroup.skeleton.bones[j];
          if (pose.affectedBones != undefined && pose.affectedBones.indexOf(bone.name) == -1){
            continue;
          }

          if (bone.name === poseBone.name){
            bone.scale.x = poseBone.scale.x;
            bone.scale.y = poseBone.scale.y;
            bone.scale.z = poseBone.scale.z;
          }
        }
      }
    }
  }

  function loadPose(pose){
    for (var i = 0; i < pose.poseBones.length; i++){
      var poseBone = pose.poseBones[i];

      for (var boneGroupUid in boneGroups.dict){
        var boneGroup = boneGroups.get(boneGroupUid);

        for (var j = 0; j < boneGroup.skeleton.bones.length; j++){
          var bone = boneGroup.skeleton.bones[j];
          if (pose.affectedBones != undefined && pose.affectedBones.indexOf(bone.name) == -1){
            continue;
          }

          if (bone.name === poseBone.name){
            bone.position.x = poseBone.position.x;
            bone.position.y = poseBone.position.y;
            bone.position.z = poseBone.position.z;

            bone.rotation.x = poseBone.rotation.x;
            bone.rotation.y = poseBone.rotation.y;
            bone.rotation.z = poseBone.rotation.z;
          }
        }
      }
    }
  }

  function loadJSONPose(jsonString){
    var pose = Pose.fromJson(jsonString);
    this.loadPose(pose);
  }

  function loadVariation(variation){
    for (var i = 0; i < variation.poseBones.length; i++){
      var poseBone = variation.poseBones[i];

      for (var boneGroupUid in boneGroups.dict){
        var boneGroup = boneGroups.get(boneGroupUid);

        for (var j = 0; j < boneGroup.skeleton.bones.length; j++){
          var bone = boneGroup.skeleton.bones[j];
          if (variation.affectedBones != undefined && variation.affectedBones.indexOf(bone.name) == -1){
            continue;
          }

          if (bone.name === poseBone.name){
            bone.scale.x = poseBone.scale.x;
            bone.scale.y = poseBone.scale.y;
            bone.scale.z = poseBone.scale.z;
          }
        }
      }
    }
  }

  function selectAsset(asset){
    // If waiting for a mesh to be selected when load, cancel it
    /*if (futureMeshToSelect != null){
      futureMeshToSelect = null;
    }*/

    // reset previously selected mesh to normal material
    if (selectedAsset != null){
      console.log(asset.template.name);
      //selectedAsset.material = model.materials['default'];
    }

    selectedAsset = asset;
  }

  function toJSON(){
    return {
      name: this.name,
      boneGroups: boneGroups.dict
    };
  }

  function getAsset(assetUid){
    for (var boneGroupUid in boneGroups.dict){
      var boneGroup = boneGroups.get(boneGroupUid);
      if (assetUid in boneGroup.assets.dict){
        return [boneGroupUid, boneGroup.assets.get(assetUid)];
      }
    }
    return null;
  }

  function clear(){
    for (var boneGroupUid in boneGroups.dict){
      this.removeBoneGroup(boneGroupUid);
    }
  }

  function exportToSTL(){
    var stlString = new THREE.STLExporter().parse(this.scene);
    var blob = new Blob([stlString], {type: 'text/plain'});
    
    FileSaver.download(blob, getName() + '.stl');
  }

  function loadPreset(presetId){
    var preset = presets[presetId];
    if (!preset){
      console.error("No such preset: " + presetId);
      return;
    }

    // Initialize an preset instance from this template
    preset.getFileContents(function(presetJson){
      console.log("Loaded preset " + preset.name + " from storage.");
      loadJsonPreset(presetJson);
    });
  }

  function loadJsonPreset(json){
    var self = this;
    preset = JSON.parse(json);

    var boneGroupsLeftToBeLoaded = Object.keys(preset.boneGroups).length;
    var boneGroupUids = {};

    // Check to make sure bone groups valid before loading preset
    for (var boneGroupInstanceId in preset.boneGroups){
      var boneGroupTemplateId = preset.boneGroups[boneGroupInstanceId];
      var template = boneGroupTemplates[boneGroupTemplateId];
      if (!template){
        console.error("No such bone group template: " + boneGroupTemplateId + ". Invalid preset.");
        return;
      }
    }

    // Load all bone groups, proceed to next step when all loaded
    for (var boneGroupInstanceId in preset.boneGroups){
      var boneGroupTemplateId = preset.boneGroups[boneGroupInstanceId];
      var template = boneGroupTemplates[boneGroupTemplateId];
      // Initialize a bone group instance from this template
      template.createInstance(function(boneGroup){
        console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
        addBoneGroup(boneGroup);

        boneGroupUids[boneGroup.name] = boneGroup.uid;
        boneGroupsLeftToBeLoaded -= 1;
        if (boneGroupsLeftToBeLoaded <= 0){
          presetBoneGroupsAdded(preset, boneGroupUids);
        }
      }, boneGroupInstanceId);
    }
  }

  function presetBoneGroupsAdded(preset, boneGroupUids){
    var self = this;
    var meshesLeftToBeLoaded = Object.keys(preset.meshes).length;

    // Attach meshes to bone groups.
    for (var assetTemplateId in preset.meshes){
      var template = assetTemplates[assetTemplateId];
      if (!template){
        console.error("No such asset template: " + assetTemplateId);
        meshesLeftToBeLoaded -= 1;
        continue;
      }

      // Initialize an asset instance from this template
      template.createInstance(function(asset){
        console.log("Loaded asset " + asset.template.name + " from storage.");

        var boneGroupUid = preset.meshes[asset.template.uuid];
        var boneGroup = boneGroups.get(boneGroupUid);
        boneGroup.addAsset(asset);
        meshesLeftToBeLoaded -= 1;
        if (meshesLeftToBeLoaded <= 0){
          presetMeshesAdded(preset, boneGroupUids);
        }
      });
    }
  }

  function presetMeshesAdded(preset, boneGroupUids){
    // Attach bone groups to their correct parent bones.
    self = this;

    for (var boneGroupInstanceId in preset.attachments){
      var boneGroup = boneGroups.get(boneGroupInstanceId);

      var attachToUid = preset.attachments[boneGroupInstanceId][0];
      var attachToBoneGroup = boneGroups.get(attachToUid);
      var attachToPoint = preset.attachments[boneGroupInstanceId][1];

      boneGroup.attachToBone(attachToUid, attachToPoint, attachToBoneGroup.attachPoints[attachToPoint]);
    }

    // Load pose.
    // if (preset.pose != undefined){
    //   self.character.loadPose(preset.pose);
    // }
  }


  /* =====================================
      Click handlers
     ===================================== */

  function handleClickBoneGroupTemplate(boneGroupTemplateId){
    var template = boneGroupTemplates[boneGroupTemplateId];
    if (!template){
      console.error("No such bone group template: " + boneGroupTemplateId);
      return;
    }

    // Initialize a bone group instance from this template
    template.createInstance(function(boneGroup){
      console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
      addBoneGroup(boneGroup);
    });

  }

  function handleClickAssetTemplate(assetTemplateId){
    var template = assetTemplates[assetTemplateId];
    if (!template){
      console.error("No such asset template: " + assetTemplateId);
      return;
    }
    console.log(template);

    // Initialize an asset instance from this template
    template.createInstance(function(asset){
      console.log("Loaded asset " + asset.template.name + " from storage.");
      var boneGroup = boneGroups.get(boneGroups.keys()[0]);
      boneGroup.addAsset(asset);
    });
  }

  function handleClickPreset(presetId){
    loadPreset(presetId);
  }

  function onLeftMouseDown(mouseX, mouseY){
    // if (this.editMode !== 'none'){
    //   this.finalizeEdit();
    //   return;
    // }
  }

  function onLeftMouseUp(mouseX, mouseY){

  }

  function onRightMouseDown(mouseX, mouseY){
    rightMouseDownXY = [mouseX, mouseY];

    if (this.editMode === 'rotate'){
      this.cancelBoneRotate();
      return;
    } else if (this.editMode === 'move'){
      this.cancelBoneMove();
      return;
    } else if (this.editMode === 'scale'){
      this.cancelBoneScale();
      return;
    }
  }

  function onRightMouseUp(mouseX, mouseY){
    if (mouseX == rightMouseDownXY[0] && mouseY == rightMouseDownXY[1]){
      onRightClick(mouseX, mouseY);
    }
  }

  function onRightClick(mouseX, mouseY){
    console.log(mouseX, mouseY);
    if (mode == 'pose'){
      var clickVector = this.getClickVector(mouseX, mouseY, this.camera);
      this.raycaster.set(this.camera.position, clickVector.sub(this.camera.position).normalize());

      var intersections = this.raycaster.intersectObjects(this.boneHandles, false);
      var closestBone = null, closestDistance = null;
      for (var i = 0; i < intersections.length; i++){
        var boneHandle = intersections[i].object;
        var boneGroup = character.boneGroups.get(boneHandle.boneGroupUid);
        var bone = boneGroup.skeleton.bones[boneHandle.boneIndex];
        if (bone.name.startsWith("#")){
          continue;
        }
        if (closestBone === null || intersections[i].distance < closestDistance){
          closestBone = bone;
          closestDistance = intersections[i].distance;
        }
      }
      this.selectedBone = closestBone;

      if (closestBone == null){
        this.boneAxisHelper.visible = false;
      } else {
        this.boneAxisHelper.visible = true;
        console.log("Clicked on " + this.selectedBone.name);

        var globalBonePosition = new THREE.Vector3()
        this.scene.updateMatrixWorld();
        globalBonePosition.setFromMatrixPosition(closestBone.matrixWorld);
        this.rotationBoneOrigin = this.getScreenCoordinates(globalBonePosition);
      }
    } else if (mode == 'mesh'){
      var pickingTexture = meshPickingView.pickingTexture;
      view.renderer.render(meshPickingView.scene, view.camera, pickingTexture);
      var pixelBuffer = new Uint8Array(4);
      view.renderer.readRenderTargetPixels(pickingTexture, mouseX, pickingTexture.height - mouseY, 1, 1, pixelBuffer);
      
      // Create id from RGB values
      var colorId = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );

      var assetUid = meshPickingView.assetUidMap[colorId];
      var assetResult = getAsset(assetUid);
      if (assetResult == null){
        selectAsset(null);
        // this.hideLibrary('mesh');
      } else {
        //boneGroupUid = assetResult[0];
        asset = assetResult[1];
        selectAsset(asset);
        // this.libraryClearMeshes();
        // this.libraryPopulateMeshes(boneGroupUid);
        // this.showLibrary('mesh');
      }
    } else if (mode == 'bone'){
      var pickingTexture = meshPickingView.pickingTexture;
      this.renderer.render(meshPickingView.scene, this.camera, pickingTexture);
      var pixelBuffer = new Uint8Array(4);
      this.renderer.readRenderTargetPixels(pickingTexture, mouseX, pickingTexture.height - mouseY, 1, 1, pixelBuffer);
      
      // Create id from RGB values
      var colorId = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
      var assetUid = meshPickingView.assetUidMap[colorId];     
      var assetResult = getAsset(assetUid);
      if (assetResult == null){
        this.selectBoneGroup(null);
      } else {
        boneGroupUid = assetResult[0];
        var boneGroup = character.boneGroups.get(boneGroupUid);
        this.selectBoneGroup(boneGroup);
      }
    }
  }

  function onMiddleMouseDown(mouseX, mouseY, event){
    console.log("Middle click");
  }

  function onMouseDown(event){
    if (event.button === 0){
      onLeftMouseDown(event.clientX, event.clientY, event);
    } else if (event.button == 1){
      onMiddleMouseDown(event.clientX, event.clientY, event);
    } else if (event.button == 2){
      onRightMouseDown(event.clientX, event.clientY, event);
    }
  }

  function onMouseUp(event){
    if (event.button === 0){
      onLeftMouseUp(event.clientX, event.clientY, event);
    } else if (event.button == 1){
      // Middle click
    } else if (event.button == 2){
      onRightMouseUp(event.clientX, event.clientY, event);
    }
  }

  document.addEventListener('mousedown', onMouseDown, false);
  document.addEventListener('mouseup', onMouseUp, false);
  //document.onmousemove = onMouseMove;
  //document.addEventListener('keydown', onKeyDown, false);

</script>