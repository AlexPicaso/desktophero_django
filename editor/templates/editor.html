<title>DesktopHero - Editor</title>

<script src="/static/jquery-3.2.1/jquery.min.js"></script>
<script src="/static/threejs/build/three.js"></script>
<script src="/static/threejs/external/OrbitControls.js"></script>
<script src="/static/threejs/external/STLExporter.js"></script>
<script src="/static/threejs/examples/js/loaders/STLLoader.js"></script>

<script src="/static/editor/js/Uuid.js"></script>
<script src="/static/editor/js/UserSettings.js"></script>
<script src="/static/editor/js/LocalDataSource.js"></script>
<script src="/static/editor/js/SceneView.js"></script>
<script src="/static/editor/js/Character.js"></script>
<script src="/static/editor/js/BoneGroup.js"></script>
<script src="/static/editor/js/BoneGroupTemplate.js"></script>
<script src="/static/editor/js/AssetTemplate.js"></script>
<script src="/static/editor/js/Asset.js"></script>
<script src="/static/editor/js/Preset.js"></script>
<script src="/static/editor/js/Pose.js"></script>
<script src="/static/editor/js/Materials.js"></script>
<script src="/static/editor/js/PickingView.js"></script>
<script src="/static/editor/js/PosePickingView.js"></script>
<script src="/static/editor/js/Event.js"></script>
<script src="/static/editor/js/ObservableDict.js"></script>
<script src="/static/editor/js/ObservableList.js"></script>
<script src="/static/editor/js/FileSaver.js"></script>
<script src="/static/editor/js/Global.js"></script>

<script>
  mode = "appearance";

  boneGroupTemplates = {};
  assetTemplates = {};
  presets = {};

  boneGroups = new ObservableDict(this);

  materials = new Materials();
  view = new SceneView(); // This is the three.js panel
  view.animate();
  meshPickingView = new PickingView();
  posePickingView = new PosePickingView();
  selectedAsset = null;
  selectedBoneGroup = null;

  // bone manipulation
  selectedBone = null;
  editMode = 'none';
  rotationBoneOrigin = null;
  editMouseOriginX = 0;
  editMouseOriginY = 0;
  raycaster = new THREE.Raycaster();
  X_AXIS = new THREE.Vector3(1,0,0);
  Y_AXIS = new THREE.Vector3(0,1,0);
  Z_AXIS = new THREE.Vector3(0,0,1);
  lastMouseX = null;
  lastMouseY = null;

  // keyboard
  leftMouseDown = false;

  $(document).ready( function(){
    view.onWindowResize(); // Resize three.js panel to correct starting size
    meshPickingView.onWindowResize(); // Resize the mesh picking view too
    posePickingView.onWindowResize(); // Resize the pose picking view too

    initializeBoneGroupTemplates();
    initializeAssetTemplates();
    initializePresets();
    initializeMaterials();

    hideAssetTabs(); // hide asset tabs 
    initializeMenus();


    loadPreset("b18a412a-00fc-4cf9-9df5-d80066bc05e7");
    view.requestRender();

    // enable clicks
    $('canvas')[0].addEventListener('mousedown', onMouseDown);
    $('canvas')[0].addEventListener('mouseup', onMouseUp);
    $('canvas')[0].addEventListener('mousemove', onMouseMove, true);
    document.addEventListener('keydown', onKeyDown, false);
  });


  function initializeBoneGroupTemplates(){
    {% for bone_group in bone_groups %}
      var template = new BoneGroupTemplate("{{ bone_group.id }}",
                                         "{{ bone_group.name }}",
                                         "{{ bone_group.description }}",
                                         "{{ bone_group.author }}",
                                         "{{ bone_group.categories }}".split(","),
                                         "{{ bone_group.date_created }}",
                                         "{{ bone_group.thumbnail.url }}",
                                         "{{ bone_group.file.url }}")
      boneGroupTemplates["{{ bone_group.id }}"] = template;
    {% endfor %}
  }

  function initializeAssetTemplates(){
    {% for asset in assets %}
      var template = new AssetTemplate("{{ asset.id }}",
                                       "{{ asset.name }}",
                                       "{{ asset.description }}",
                                       "{{ asset.author }}",
                                       "{{ asset.category }}",
                                       "{{ asset.date_created }}",
                                       "{{ asset.thumbnail.url }}",
                                       "{{ asset.mesh.url }}",
                                       "{{ asset.mesh_hires.url }}",
                                       "{{ asset.mesh_lowres.url }}")
      assetTemplates["{{ asset.id }}"] = template;
    {% endfor %}
  }

  function initializePresets(){
    {% for preset in presets %}
      var preset = new Preset( "{{ preset.id }}",
                               "{{ preset.name }}",
                               "{{ preset.description }}",
                               "{{ preset.author }}",
                               "{{ preset.category }}",
                               "{{ preset.date_created }}",
                               "{{ preset.thumbnail.url }}",
                               "{{ preset.file.url }}")
      presets["{{ preset.id }}"] = preset;
    {% endfor %}
  }

  function initializeMaterials(){
    materials.metallic = Materials.createReflectiveMaterial(new THREE.Color(0.75, 0.75, 0.7), .3, view.cubeMap);
    materials.selected = Materials.createReflectiveMaterial(new THREE.Color(0.7, .8, .9), .2, view.cubeMap);
    materials.boneGroupSelected = Materials.createReflectiveMaterial(new THREE.Color(0.9, .8, .6), .2, view.cubeMap);
    materials.clay = Materials.createReflectiveMaterial(new THREE.Color(0.5, 0.4, 0.5), 0.02, view.cubeMap);
    materials.basicGray = Materials.createBasicMaterial(new THREE.Color(0.6, 0.58, 0.6));
    materials.transparentGray = Materials.createTransparentMaterial(new THREE.Color(0.6, 0.58, 0.6));
    materials.default = materials.metallic;
  }

  function addBoneGroup(boneGroup){
    boneGroups.put(boneGroup.uid, boneGroup);
  }

  function removeBoneGroup(uid){
    // Remove meshes attached to bone group
    var boneGroupToRemove = boneGroups.get(uid);
    for (var meshName in boneGroupToRemove.assets.dict){
      boneGroupToRemove.removeMesh(meshName);
    }

    for (var boneGroupUid in boneGroups.dict){
      var boneGroup = boneGroups.get(boneGroupUid);
      if (boneGroup.parentBoneGroupUid === uid){ //Remove child bone groups.
        removeBoneGroup(boneGroupUid);
      }
    }
    boneGroups.remove(uid);
  }

  function getCurrentPose(){
    return Pose.toPose(boneGroups);
  }

  function loadBoneScales(pose){
    for (var i = 0; i < pose.poseBones.length; i++){
      var poseBone = pose.poseBones[i];

      for (var boneGroupUid in boneGroups.dict){
        var boneGroup = boneGroups.get(boneGroupUid);

        for (var j = 0; j < boneGroup.skeleton.bones.length; j++){
          var bone = boneGroup.skeleton.bones[j];
          if (pose.affectedBones != undefined && pose.affectedBones.indexOf(bone.name) == -1){
            continue;
          }

          if (bone.name === poseBone.name){
            bone.scale.x = poseBone.scale.x;
            bone.scale.y = poseBone.scale.y;
            bone.scale.z = poseBone.scale.z;
          }
        }
      }
    }
  }

  function loadPose(pose){
    for (var i = 0; i < pose.poseBones.length; i++){
      var poseBone = pose.poseBones[i];

      for (var boneGroupUid in boneGroups.dict){
        var boneGroup = boneGroups.get(boneGroupUid);

        for (var j = 0; j < boneGroup.skeleton.bones.length; j++){
          var bone = boneGroup.skeleton.bones[j];
          if (pose.affectedBones != undefined && pose.affectedBones.indexOf(bone.name) == -1){
            continue;
          }

          if (bone.name === poseBone.name){
            bone.position.x = poseBone.position.x;
            bone.position.y = poseBone.position.y;
            bone.position.z = poseBone.position.z;

            bone.rotation.x = poseBone.rotation.x;
            bone.rotation.y = poseBone.rotation.y;
            bone.rotation.z = poseBone.rotation.z;
          }
        }
      }
    }
  }

  function loadJSONPose(jsonString){
    var pose = Pose.fromJson(jsonString);
    this.loadPose(pose);
  }

  function loadVariation(variation){
    for (var i = 0; i < variation.poseBones.length; i++){
      var poseBone = variation.poseBones[i];

      for (var boneGroupUid in boneGroups.dict){
        var boneGroup = boneGroups.get(boneGroupUid);

        for (var j = 0; j < boneGroup.skeleton.bones.length; j++){
          var bone = boneGroup.skeleton.bones[j];
          if (variation.affectedBones != undefined && variation.affectedBones.indexOf(bone.name) == -1){
            continue;
          }

          if (bone.name === poseBone.name){
            bone.scale.x = poseBone.scale.x;
            bone.scale.y = poseBone.scale.y;
            bone.scale.z = poseBone.scale.z;
          }
        }
      }
    }
  }

  function selectAsset(asset){
    // reset previously selected mesh to normal material
    if (selectedAsset != null){
      selectedAsset.mesh.material = materials.default;
    }
    view.requestRender();

    selectedAsset = asset;
    if (selectedAsset == null){
      return;
    }

    // reset newly selected mesh to selected material
    console.log("Selected asset " + asset.template.name);
    selectedAsset.mesh.material = materials.selected;
    view.requestRender();

    // show appropriate asset categories on the appearance menu
    hideAssetTabs();
    var boneGroup = boneGroups.get(selectedAsset.boneGroupUid);
    var categories = boneGroup.template.categories;
    for (var i = 0; i < categories.length; i++ ){
      var category = categories[i];
      showAssetTab(category);
    }
    setActiveAssetTab(categories[0]);
  }

  function selectBoneGroup(boneGroup){
    menuSelectBoneGroup(boneGroup);

    // reset previously selected bone group to normal material
    if (selectedBoneGroup != null){
      for (var assetId in selectedBoneGroup.assets.dict){
        var asset = selectedBoneGroup.assets.get(assetId);
        asset.mesh.material  = materials.default;
      }
    }
    view.requestRender();

    selectedBoneGroup = boneGroup;
    if (selectedBoneGroup == null){
      return;
    }

    // reset newly selected bone group to selected material
    console.log("Selected bone group " + boneGroup.template.name);
    for (var assetId in boneGroup.assets.dict){
      var asset = boneGroup.assets.get(assetId);
      asset.mesh.material  = materials.boneGroupSelected;
    }
    
    view.requestRender();



    // show appropriate asset categories on the appearance menu
    /*hideAssetTabs();
    var boneGroup = boneGroups.get(selectedAsset.boneGroupUid);
    var categories = boneGroup.template.categories;
    for (var i = 0; i < categories.length; i++ ){
      var category = categories[i];
      showAssetTab(category);
    }
    setActiveAssetTab(categories[0]);*/
  }

  function setMode(setTo){
    console.log("Entering " + setTo + " mode.");
    mode = setTo;

    if (mode != 'mesh' && selectedAsset != null){
      selectAsset(null);
    }

    if (mode != 'components' && selectedBoneGroup != null){
      selectBoneGroup(null);
    }

    view.requestRender();
  }

  function toJSON(){
    return {
      name: this.name,
      boneGroups: boneGroups.dict
    };
  }

  function getAsset(assetUid){
    for (var boneGroupUid in boneGroups.dict){
      var boneGroup = boneGroups.get(boneGroupUid);
      if (assetUid in boneGroup.assets.dict){
        return [boneGroupUid, boneGroup.assets.get(assetUid)];
      }
    }
    return null;
  }

  function clear(){
    for (var boneGroupUid in boneGroups.dict){
      this.removeBoneGroup(boneGroupUid);
    }
  }

  function exportToSTL(){
    var stlString = new THREE.STLExporter().parse(view.scene);
    var blob = new Blob([stlString], {type: 'text/plain'});
    
    FileSaver.download(blob, 'New Character.stl');
  }

  function loadPreset(presetId){
    var preset = presets[presetId];
    if (!preset){
      console.error("No such preset: " + presetId);
      return;
    }

    // Initialize an preset instance from this template
    preset.getFileContents(function(presetJson){
      console.log("Loaded preset " + preset.name + " from storage.");
      loadJsonPreset(presetJson);
    });
  }

  function loadJsonPreset(json){
    var self = this;
    preset = JSON.parse(json);

    var boneGroupsLeftToBeLoaded = Object.keys(preset.boneGroups).length;
    var boneGroupUids = {};

    // Check to make sure bone groups valid before loading preset
    for (var boneGroupInstanceId in preset.boneGroups){
      var boneGroupTemplateId = preset.boneGroups[boneGroupInstanceId];
      var template = boneGroupTemplates[boneGroupTemplateId];
      if (!template){
        console.error("No such bone group template: " + boneGroupTemplateId + ". Invalid preset.");
        return;
      }
    }

    // Load all bone groups, proceed to next step when all loaded
    for (var boneGroupInstanceId in preset.boneGroups){
      var boneGroupTemplateId = preset.boneGroups[boneGroupInstanceId];
      var template = boneGroupTemplates[boneGroupTemplateId];
      // Initialize a bone group instance from this template
      template.createInstance(function(boneGroup){
        console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
        addBoneGroup(boneGroup);

        boneGroupUids[boneGroup.name] = boneGroup.uid;
        boneGroupsLeftToBeLoaded -= 1;
        if (boneGroupsLeftToBeLoaded <= 0){
          presetBoneGroupsAdded(preset, boneGroupUids);
        }
      }, boneGroupInstanceId);
    }
  }

  function presetBoneGroupsAdded(preset, boneGroupUids){
    var self = this;
    var meshesLeftToBeLoaded = Object.keys(preset.meshes).length;

    // Attach meshes to bone groups.
    for (var assetTemplateId in preset.meshes){
      var template = assetTemplates[assetTemplateId];
      if (!template){
        console.error("No such asset template: " + assetTemplateId);
        meshesLeftToBeLoaded -= 1;
        continue;
      }

      // Initialize an asset instance from this template
      template.createInstance(function(asset){
        console.log("Loaded asset " + asset.template.name + " from storage.");

        var boneGroupUid = preset.meshes[asset.template.uuid];
        var boneGroup = boneGroups.get(boneGroupUid);
        boneGroup.addAsset(asset);
        meshesLeftToBeLoaded -= 1;
        if (meshesLeftToBeLoaded <= 0){
          presetMeshesAdded(preset, boneGroupUids);
        }
      });
    }
  }

  function presetMeshesAdded(preset, boneGroupUids){
    // Attach bone groups to their correct parent bones.
    self = this;

    for (var boneGroupInstanceId in preset.attachments){
      var boneGroup = boneGroups.get(boneGroupInstanceId);

      var attachToUid = preset.attachments[boneGroupInstanceId][0];
      var attachToBoneGroup = boneGroups.get(attachToUid);
      var attachToPoint = preset.attachments[boneGroupInstanceId][1];

      boneGroup.attachToBone(attachToUid, attachToPoint, attachToBoneGroup.attachPoints[attachToPoint]);
    }

    // Load pose.
    // if (preset.pose != undefined){
    //   self.character.loadPose(preset.pose);
    // }
  }


  /* =====================================
      Click handlers
     ===================================== */

  function handleClickBoneGroupTemplate(boneGroupTemplateId){
    var template = boneGroupTemplates[boneGroupTemplateId];
    if (!template){
      console.error("No such bone group template: " + boneGroupTemplateId);
      return;
    }

    // Initialize a bone group instance from this template
    template.createInstance(function(boneGroup){
      console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
      addBoneGroup(boneGroup);
    });

  }

  function handleClickAssetTemplate(assetTemplateId){
    var template = assetTemplates[assetTemplateId];
    if (!template){
      console.error("No such asset template: " + assetTemplateId);
      return;
    }

    // Initialize an asset instance from this template
    template.createInstance(function(asset){
      console.log("Loaded asset " + asset.template.name + " from storage.");
      // Add asset to bone group of selected asset
      if (selectedAsset == null){
        // TODO: what to do if no asset selected?
      } else {
        var boneGroup = boneGroups.get(selectedAsset.boneGroupUid);
        // remove mesh that's already there
        boneGroup.removeAsset(selectedAsset.uid);

        // add new meshrr
        boneGroup.addAsset(asset);
        selectAsset(asset);
      }
    });
  }

  function handleClickBoneGroupTemplate(boneGroupTemplateId){
    var template = boneGroupTemplates[boneGroupTemplateId];
    if (!template){
      console.error("No such bone group template: " + boneGroupTemplateId);
      return;
    }

    // Initialize an asset instance from this template
    template.createInstance(function(boneGroup){
      console.log("Loaded bone group " + boneGroup.template.name + " from storage.");
      // Add asset to bone group of selected asset
      if (selectedBoneGroup == null){
        // TODO: what to do if no bone group selected?
      } else {
        /*var boneGroup = boneGroups.get(selectedAsset.boneGroupUid);
        // remove mesh that's already there
        boneGroup.removeAsset(selectedAsset.uid);

        // add new mesh
        boneGroup.addAsset(asset);
        selectAsset(asset);*/
      }
    });
  }

  function handleClickPreset(presetId){
    loadPreset(presetId);
  }

  function handleModeClick(mode){
    setMode(mode);
  }

  function onLeftMouseDown(mouseX, mouseY){
    leftMouseDown = true;
    if (editMode !== 'none'){
      finalizeEdit();
    }
  }

  function onLeftMouseUp(mouseX, mouseY){
    leftMouseDown = false;

    view.finalizeCameraMove();
  }

  function onRightMouseDown(mouseX, mouseY){
    rightMouseDownXY = [mouseX, mouseY];

    if (editMode === 'rotate'){
      cancelBoneRotate();
      return;
    } else if (editMode === 'move'){
      cancelBoneMove();
      return;
    } else if (editMode === 'scale'){
      cancelBoneScale();
      return;
    }
  }

  function onRightMouseUp(mouseX, mouseY){
    if (mouseX == rightMouseDownXY[0] && mouseY == rightMouseDownXY[1]){
      onRightClick(mouseX, mouseY);
    }
    view.finalizeCameraMove();
  }

  function onRightClick(mouseX, mouseY){
    console.log(mouseX, mouseY);
    /*if (mode == 'pose'){
      var clickVector = this.getClickVector(mouseX, mouseY, this.camera);
      this.raycaster.set(this.camera.position, clickVector.sub(this.camera.position).normalize());

      var intersections = this.raycaster.intersectObjects(this.boneHandles, false);
      var closestBone = null, closestDistance = null;
      for (var i = 0; i < intersections.length; i++){
        var boneHandle = intersections[i].object;
        var boneGroup = character.boneGroups.get(boneHandle.boneGroupUid);
        var bone = boneGroup.skeleton.bones[boneHandle.boneIndex];
        if (bone.name.startsWith("#")){
          continue;
        }
        if (closestBone === null || intersections[i].distance < closestDistance){
          closestBone = bone;
          closestDistance = intersections[i].distance;
        }
      }
      selectedBone = closestBone;

      if (closestBone == null){
        this.boneAxisHelper.visible = false;
      } else {
        this.boneAxisHelper.visible = true;
        console.log("Clicked on " + selectedBone.name);

        var globalBonePosition = new THREE.Vector3()
        this.scene.updateMatrixWorld();
        globalBonePosition.setFromMatrixPosition(closestBone.matrixWorld);
        rotationBoneOrigin = this.getScreenCoordinates(globalBonePosition);
      }
    } else */if (mode == "appearance" || mode == "components"){
      var pickingTexture = meshPickingView.pickingTexture;
      view.renderer.render(meshPickingView.scene, view.camera, pickingTexture);
      var pixelBuffer = new Uint8Array(4);
      view.renderer.readRenderTargetPixels(pickingTexture, mouseX, pickingTexture.height - mouseY, 1, 1, pixelBuffer);
      
      // Create id from RGB values
      var colorId = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
      var assetUid = meshPickingView.assetUidMap[colorId];
      var assetResult = getAsset(assetUid);
      if (assetResult == null){
        selectAsset(null);
        selectBoneGroup(null);
        // this.hideLibrary("appearance");
      } else {
        //var boneGroupUid = assetResult[0];
        var asset = assetResult[1];
        if (mode == "appearance"){
          selectAsset(asset);
        } else if (mode == "components"){
          var boneGroup = boneGroups.get(asset.boneGroupUid);
          selectBoneGroup(boneGroup);
        }
        
        // this.libraryClearMeshes();
        // this.libraryPopulateMeshes(boneGroupUid);
        // this.showLibrary("appearance");
      }
    } else if (mode == "pose" || mode == "pose picking"){
      var pickingTexture = posePickingView.pickingTexture;
      view.renderer.render(posePickingView.scene, view.camera, pickingTexture);
      var pixelBuffer = new Uint8Array(4);
      view.renderer.readRenderTargetPixels(pickingTexture, mouseX, pickingTexture.height - mouseY, 1, 1, pixelBuffer);
      
      // Create id from RGB values
      var colorId = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
      var bone = posePickingView.boneMap[colorId];
      posePickingView.markBoneSelected(selectedBone, false);
      selectedBone = bone;
      posePickingView.markBoneSelected(selectedBone, true);
      if (bone){
        console.log(bone.name);

        var globalBonePosition = new THREE.Vector3()
        view.scene.updateMatrixWorld();
        globalBonePosition.setFromMatrixPosition(bone.matrixWorld);
        rotationBoneOrigin = getScreenCoordinates(globalBonePosition);
      } else {
        // deselect bone
      }
    }

      /*else if (mode == 'bone'){
      var pickingTexture = meshPickingView.pickingTexture;
      this.renderer.render(meshPickingView.scene, this.camera, pickingTexture);
      var pixelBuffer = new Uint8Array(4);
      this.renderer.readRenderTargetPixels(pickingTexture, mouseX, pickingTexture.height - mouseY, 1, 1, pixelBuffer);
      
      // Create id from RGB values
      var colorId = ( pixelBuffer[0] << 16 ) | ( pixelBuffer[1] << 8 ) | ( pixelBuffer[2] );
      var assetUid = meshPickingView.assetUidMap[colorId];     
      var assetResult = getAsset(assetUid);
      if (assetResult == null){
        this.selectBoneGroup(null);
      } else {
        boneGroupUid = assetResult[0];
        var boneGroup = character.boneGroups.get(boneGroupUid);
        this.selectBoneGroup(boneGroup);
      }
    }*/
  }

  function onMiddleMouseDown(mouseX, mouseY, event){
    console.log("Middle click");
  }

  function onMouseDown(event){
    if (event.button === 0){
      onLeftMouseDown(event.clientX, event.clientY, event);
    } else if (event.button == 1){
      onMiddleMouseDown(event.clientX, event.clientY, event);
    } else if (event.button == 2){
      onRightMouseDown(event.clientX, event.clientY, event);
    }
  }

  function onMouseUp(event){
    if (event.button === 0){
      onLeftMouseUp(event.clientX, event.clientY, event);
    } else if (event.button == 1){
      // Middle click
    } else if (event.button == 2){
      onRightMouseUp(event.clientX, event.clientY, event);
    }
  }

  function startBoneRotate(mouseX, mouseY){
    if (!selectedBone){
      return;
    }

    console.log("Entering rotate mode.");
    editMode = 'rotate';
    initialRotation = selectedBone.rotation.clone();
    editAxis = null;

    editMouseOriginX = mouseX;
    editMouseOriginY = mouseY;
  }

  function startBoneMove(mouseX, mouseY){
    if (!selectedBone){
      return;
    }

    console.log("Entering move mode.");
    editMode = 'move';
    initialPosition = selectedBone.position.clone();
    editAxis = null;

    editMouseOriginX = mouseX;
    editMouseOriginY = mouseY;
  }

  function startBoneScale(mouseX, mouseY){
    if (!selectedBone){
      return;
    }

    console.log("Entering scale mode.");
    editMode = 'scale';
    initialScale = selectedBone.scale.clone();
    editAxis = null;

    editMouseOriginX = mouseX;
    editMouseOriginY = mouseY;
  }

  function finalizeEdit(){
    editMode = 'none';
    posePickingView.update();
  }

  function cancelBoneRotate(){
    console.log("Cancelling bone rotate.");
    selectedBone.rotation.setFromVector3(initialRotation);
    editMode = 'none';
    posePickingView.update();
  }

  function cancelBoneMove(){
    console.log("Cancelling bone move.");
    selectedBone.position.x = initialPosition.x;
    selectedBone.position.y = initialPosition.y;
    selectedBone.position.z = initialPosition.z;
    editMode = 'none';
    posePickingView.update();
  }

  function cancelBoneScale(){
    console.log("Cancelling bone scale.");
    selectedBone.scale.x = initialScale.x;
    selectedBone.scale.y = initialScale.y;
    selectedBone.scale.z = initialScale.z;

    editMode = 'none';
    posePickingView.update();
  }

  function setEditAxis(axis){
    if (editMode === 'rotate'){
      selectedBone.rotation.setFromVector3(initialRotation);
    } else if (editMode === 'move'){
      selectedBone.position.x = initialPosition.x;
      selectedBone.position.y = initialPosition.y;
      selectedBone.position.z = initialPosition.z;
    } else if (editMode === 'scale'){
      selectedBone.scale.x = initialScale.x;
      selectedBone.scale.y = initialScale.y;
      selectedBone.scale.z = initialScale.z;
    } else {
      console.error("Cannot set edit axis, not in any edit mode.");
      return;
    }

    if (axis == 'X' || axis == 'x'){
      editAxis = 'X';
    } else if (axis == 'Y' || axis == 'y'){
      editAxis = 'Y';
    } else if (axis == 'Z' || axis == 'z'){
      editAxis = 'Z';
    }
    console.log("Edit axis set to " + editAxis + ".");
  }

  function getScreenCoordinates(obj){
    var editor_panel = document.getElementById('editor_panel');
    var vector = obj.clone();
    var windowWidth = editor_panel.offsetWidth;
    var minWidth = 1280;

    if(windowWidth < minWidth) {
      windowWidth = minWidth;
    }

    var widthHalf = (windowWidth/2);
    var heightHalf = (editor_panel.offsetHeight/2);

    vector.project(view.camera);

    vector.x = ( vector.x * widthHalf ) + widthHalf;
    vector.y = - ( vector.y * heightHalf ) + heightHalf;
    vector.z = 0;

    return vector;
  }

  function getClickVector(mouseX, mouseY, camera){
    var editor_panel = document.getElementById('editor_panel');
    var vector = new THREE.Vector3(
      ( mouseX / editor_panel.offsetWidth ) * 2 - 1,
      - ( mouseY / editor_panel.offsetHeight ) * 2 + 1,
      0.5
    );
    vector.unproject(camera);
    return vector;
  }

  function onMouseMove(event){
    var mouseX = event.clientX;
    var mouseY = event.clientY;
    lastMouseX = mouseX;
    lastMouseY = mouseY;
    if (editMode === 'none'){
      return;
    } else if (editMode === 'rotate'){
      var factor = 500.0;

      var dx = (editMouseOriginX - rotationBoneOrigin.x);
      var dy = (editMouseOriginY - rotationBoneOrigin.y);
      var angle1 = Math.atan2(dy, dx);

      dx = (mouseX - rotationBoneOrigin.x);
      dy = (mouseY - rotationBoneOrigin.y);
      var angle2 = Math.atan2(dy, dx);

      var combinedAngle = angle1 - angle2;

      selectedBone.rotation.setFromVector3(initialRotation);
      selectedBone.updateMatrix();
      var rotation = selectedBone.parent.getWorldRotation()
      var inverseRotation = new THREE.Euler(rotation.x * -1, rotation.y * -1, rotation.z * -1, rotation.order);

      if (editAxis == 'X'){
        var axisClone = X_AXIS.clone();
        axisClone.applyEuler(inverseRotation);
        selectedBone.rotateOnWorldAxis(axisClone, combinedAngle);
      } else if (editAxis == 'Y'){
        var axisClone = Y_AXIS.clone();
        axisClone.applyEuler(inverseRotation);
        selectedBone.rotateOnWorldAxis(axisClone, combinedAngle);
      } else if (editAxis == 'Z'){
        var axisClone = Z_AXIS.clone();
        axisClone.applyEuler(inverseRotation);
        selectedBone.rotateOnWorldAxis(axisClone, combinedAngle);
      } else {
        var editor_panel = document.getElementById('editor_panel');
        var cameraAxis = getClickVector(editor_panel.offsetWidth/2, editor_panel.offsetHeight/2, view.camera);
        cameraAxis.applyEuler(inverseRotation);
        selectedBone.rotateOnWorldAxis(cameraAxis, combinedAngle);
      }
    } else if (editMode === 'move'){
      var dx = (mouseX - editMouseOriginX);
      var dy = (mouseY - editMouseOriginY);
      var distance = Math.sqrt(dx * dx + dy * dy);

      if (editAxis == 'X'){
        selectedBone.position.x = initialPosition.x + dx/100.0;
      } else if (editAxis == 'Y'){
        selectedBone.position.y = initialPosition.y - dy/100.0;
      } else if (editAxis == 'Z'){
        selectedBone.position.z = initialPosition.z + dx/100.0;
      } else {
        
      }

    } else if (editMode === 'scale'){
      //TODO: This 'distance1' stuff doesn't need to be calculated each time the mouse is moved. Same above.
      var dx = (editMouseOriginX - rotationBoneOrigin.x);
      var dy = (editMouseOriginY - rotationBoneOrigin.y);
      var distance1 = Math.sqrt(dx * dx + dy * dy);

      var dx = (mouseX - rotationBoneOrigin.x);
      var dy = (mouseY - rotationBoneOrigin.y);
      var distance2 = Math.sqrt(dx * dx + dy * dy);
      
      var scaleAmount = (distance2 - distance1)/200.0;
      if (editAxis == 'X'){
        selectedBone.scale.x = initialScale.x + scaleAmount;
      } else if (editAxis == 'Y'){
        selectedBone.scale.y = initialScale.y + scaleAmount;
      } else if (editAxis == 'Z'){
        selectedBone.scale.z = initialScale.z + scaleAmount;
      } else {
        selectedBone.scale.x = initialScale.x + scaleAmount;
        selectedBone.scale.y = initialScale.y + scaleAmount;
        selectedBone.scale.z = initialScale.z + scaleAmount;
      }
    }
    view.requestRender();
  }

  function onKeyDown(event){
    var keynum; 
    if(window.event) { // IE                    
      keynum = event.keyCode;
    } else if(event.which){ // Netscape/Firefox/Opera                   
      keynum = event.which;
    }

    if (keynum == 46){ // Delete
      onDeletePressed();
    } else if (keynum == 219){ // 
      setMode('mesh picking');
    } else if (keynum == 221){ // 

    }

    var letter = String.fromCharCode(keynum);

    if (letter == 'P' || letter == 'p'){
      setMode('pose');
    } else if (letter == 'M' || letter == 'm'){
      setMode('appearance');
    } else if (letter == 'B' || letter == 'b'){
      setMode('components');
    } else if (letter == 'R' || letter == 'r'){
      startBoneRotate(lastMouseX, lastMouseY);
    } else if (letter == 'G' || letter == 'g'){
      startBoneMove(lastMouseX, lastMouseY);
    } else if (letter == 'S' || letter == 's'){
      startBoneScale(lastMouseX, lastMouseY);
    } else if ('XxYyZz'.indexOf(letter) != -1){
      setEditAxis(letter);
    }
}
  

</script>